#!/bin/bash
set -e
PIXITAINER_VERSION="0.3.2"

# --- Valeurs par d√©faut ---
OUTPUT="pixitainer.sif"
PROJECT_PATH="."
SEAMLESS=false
BASE_IMAGE="ubuntu:24.04"
TARGET_PIXI_VERSION=""
KEEP_DEF=false
VERBOSE=false
QUIET=false
declare -a ENVS
declare -a EXTRA_FILES

# --- Fonction d'aide ---
usage() {
    echo "Usage: pixi containerize [options]"
    echo ""
    echo "Pixi extension to containerize a project with Apptainer."
    echo "Version: $PIXITAINER_VERSION"
    echo ""
    echo "Options:"
    echo "  -o, --output OUTPUT       Output image path (default: pixitainer.sif)"
    echo "  -p, --path PATH           Working directory (source project)"
    echo "  -s, --seamless            Enable seamless execution"
    echo "  -e, --env ENV             Specific environment(s) to install (can be used multiple times)"
    echo "  -q, --quiet               Quiet mode (suppress all output, return 0 on success, 1 on error)"
    echo "  -v, --verbose             Verbose mode (show full Apptainer build output)"
    echo "  --base-image IMAGE        Specify base image (default: ubuntu:24.04)"
    echo "  --pixi-version VERSION    Specify pixi version (default: latest)"
    echo "  --add-file SRC:DEST       Add a file to the container (format: source:destination)"
    echo "  --keep-def                Export the .def file (do not delete temporary files)"
    echo "  -h, --help                Show this help message"
}

# Wrapper to echo only if not quiet
log() {
    if [ "$QUIET" = false ]; then
        echo "$@"
    fi
}

# --- Parsing des arguments ---
while [[ $# -gt 0 ]]; do
    case $1 in
        -o|--output)
            OUTPUT="$2"
            shift 2
            ;;
        -p|--path)
            PROJECT_PATH="$2"
            shift 2
            ;;
        -s|--seamless)
            SEAMLESS=true
            shift
            ;;
        -e|--env)
            ENVS+=("$2")
            shift 2
            ;;
        -q|--quiet)
            QUIET=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        --base-image)
            BASE_IMAGE="$2"
            shift 2
            ;;
        --pixi-version)
            TARGET_PIXI_VERSION="$2"
            shift 2
            ;;
        --add-file)
            EXTRA_FILES+=("$2")
            shift 2
            ;;
        --keep-def)
            KEEP_DEF=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "Error: Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# --- R√©solution des chemins ---
WD=$(cd "$PROJECT_PATH" && pwd -P)
# Pour l'output, on g√®re le cas o√π le fichier n'existe pas encore
OUTPUT_DIR=$(dirname "$OUTPUT")
# Si output est relatif, on le rend absolu par rapport au dossier courant
if [[ "$OUTPUT_DIR" == "." ]]; then
    OUTPUT_ABS="$(pwd -P)/$OUTPUT"
    OUTPUT_PARENT="$(pwd -P)"
else
    mkdir -p "$OUTPUT_DIR"
    OUTPUT_ABS="$(cd "$OUTPUT_DIR" && pwd -P)/$(basename "$OUTPUT")"
    OUTPUT_PARENT="$(cd "$OUTPUT_DIR" && pwd -P)"
fi

TMP_DIR="$OUTPUT_PARENT/.tmp_pixitainer"
PIXI_TOML="$WD/pixi.toml"
PIXI_LOCK="$WD/pixi.lock"

# --- V√©rifications ---
if [ ! -f "$PIXI_TOML" ]; then
    if [ "$QUIET" = false ]; then
        echo "Error: pixi.toml not found in $WD"
    fi
    exit 1
fi

log "üì¶ Containerizing project from: $WD"
log "üìÇ Output target: $OUTPUT_ABS"

# --- Pr√©paration du .def ---
mkdir -p "$TMP_DIR"
TARGET_DEF="$TMP_DIR/pixitainer.def"

# Construction de la section %files
FILES_SECTION="    \"$PIXI_TOML\" /opt/conf/pixi.toml"
if [ -f "$PIXI_LOCK" ]; then
    FILES_SECTION="$FILES_SECTION"$'\n'"    \"$PIXI_LOCK\" /opt/conf/pixi.lock"
fi

# Rajoute des fichiers suppl√©mentaires
for file_spec in "${EXTRA_FILES[@]}"; do
    # Split "source:destination"
    if [[ "$file_spec" == *":"* ]]; then
        src="${file_spec%%:*}"
        dest="${file_spec#*:}"
        FILES_SECTION="$FILES_SECTION"$'\n'"    \"$src\" \"$dest\""
    else
        # If no destination is provided, Apptainer copies it to the root or preserves name
        FILES_SECTION="$FILES_SECTION"$'\n'"    \"$file_spec\""
    fi
done

# Construction de la commande d'installation
if [ ${#ENVS[@]} -gt 0 ]; then
    ENV_FLAGS=""
    for env in "${ENVS[@]}"; do
        ENV_FLAGS="$ENV_FLAGS -e $env"
    done
    INSTALL_CMD="pixi install $ENV_FLAGS --frozen"
else
    INSTALL_CMD="pixi install -a --frozen"
fi

# Logique Seamless
if [ "$SEAMLESS" = true ]; then
    RUNSCRIPT_CONTENT='pixi run --as-is -m /opt/conf/pixi.toml "$@"'
else
    RUNSCRIPT_CONTENT='exec "$@"'
fi

# Gestion de la version de Pixi
PIXI_VERSION_ENV=""
if [ -n "$TARGET_PIXI_VERSION" ]; then
    PIXI_VERSION_ENV="pixi self-update --version $TARGET_PIXI_VERSION"
fi

# √âcriture du fichier de d√©finition (Here-Doc)
# Note: We inject "STEP:" echoes to track progress in non-verbose mode
cat <<EOF > "$TARGET_DEF"
Bootstrap: docker
From: $BASE_IMAGE

%files
$FILES_SECTION

%environment
    export PIXI_HOME=/opt/pixi
    export PIXI_PROJECT_MANIFEST=/opt/conf/pixi.toml
    export PATH="/opt/pixi/bin:\$PATH"

%post
    export DEBIAN_FRONTEND=noninteractive

    # 1. Install system dependencies
    echo "STEP: Updating the image"
    apt-get update && apt-get install -y curl

    # 2. Install Pixi globally to /opt/pixi
    export PIXI_HOME=/opt/pixi
    echo "STEP: Downloading Pixi"
    curl -fsSL https://pixi.sh/install.sh | bash
    export PATH="/opt/pixi/bin:\$PATH"

    $PIXI_VERSION_ENV

    # 3. Setup the Project Environment
    mkdir -p /opt/conf
    cd /opt/conf

    echo "STEP: Installing the environment"
    pixi config set --local run-post-link-scripts insecure
    $INSTALL_CMD

    # 4. Cleanup
    echo "STEP: Cleaning"
    apt-get remove -y curl
    apt-get autoremove -y
    apt-get clean
    rm -rf /var/lib/apt/lists/*

%runscript
    $RUNSCRIPT_CONTENT
EOF

# --- Build Apptainer ---
log "üöÄ Starting Apptainer build..."

CMD=(apptainer build --force --fakeroot "$OUTPUT_ABS" "$TARGET_DEF")

if [ "$QUIET" = true ]; then
    # Quiet Mode: Run completely silently.
    if ! "${CMD[@]}" > /dev/null 2>&1; then
        exit 1
    fi
elif [ "$VERBOSE" = true ]; then
    # Verbose Mode: Run directly
    "${CMD[@]}"
else
    # Normal Mode: Spinner UI

    # Temp files
    LOG_FILE="$(mktemp)"
    STEP_FILE="$(mktemp)" # To track current step across subshells

    # Init step
    CURRENT_STEP="Presetup (downloading image, importing files)"
    echo "$CURRENT_STEP" > "$STEP_FILE"

    # Spinner chars
    SPIN='-\|/'
    i=0

    # Hide Cursor
    tput civis 2>/dev/null || true

    # Trap to restore cursor and clean log on exit
    trap 'tput cnorm 2>/dev/null || true; rm -f "$LOG_FILE" "$STEP_FILE"' EXIT

    set -o pipefail
    set +e

    # Run build, pipe output to loop
    "${CMD[@]}" 2>&1 | while IFS= read -r line; do
        # Save output to log file
        echo "$line" >> "$LOG_FILE"

        # Check for our injected STEP markers
        if [[ "$line" == "STEP: "* ]]; then
            # Mark previous step as done (overwrite spinner line with checkmark)
            printf "\r [‚úÖ] %s\033[K\n" "$CURRENT_STEP"

            # Update to new step
            CURRENT_STEP="${line#STEP: }"
            echo "$CURRENT_STEP" > "$STEP_FILE"

            # Reset spinner
            i=0
        fi

        # Update Spinner for CURRENT step
        printf "\r [${SPIN:i++%4:1}] %s\033[K" "$CURRENT_STEP"
    done

    EC=$?

    # Retrieve the very last step state from the temp file
    LAST_STEP=$(cat "$STEP_FILE")

    if [ $EC -eq 0 ]; then
        # Mark the final step as done
        printf "\r [‚úÖ] %s\033[K\n" "$LAST_STEP"
    else
        # Mark the final step as failed
        printf "\r [‚ùå] %s\033[K\n" "$LAST_STEP"
        echo ""
        echo "‚ùå Final build failed."
        echo ""
        echo "--- LOGS ---"
        cat "$LOG_FILE"
        exit $EC
    fi
fi

log "‚úÖ Success! Image built at: $OUTPUT_ABS"

# Cleanup
if [ "$KEEP_DEF" = true ]; then
    log "‚ÑπÔ∏è  Definition file kept at: $TARGET_DEF"
else
    if [ -d "$TMP_DIR" ]; then
        rm -rf "$TMP_DIR"
    fi
fi